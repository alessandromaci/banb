# Design Document - Banb MVP v1

## Overview

Banb MVP v1 extends the existing crypto neobank foundation to support multi-chain operations (Base + Solana), cross-chain transfers, lending/borrowing on both chains, AI-powered analytics and automation, and simulated card spending. The design maintains the existing profile-centric architecture while adding Solana support, cross-chain bridging capabilities, and enhanced AI features.

### Key Design Principles

1. **Profile-Centric Architecture**: One user profile maps to multiple accounts/wallets across chains
2. **Data Consistency**: Maintain sync between Privy (wallet management) and Supabase (profile/transaction data)
3. **Modular Chain Support**: Isolate chain-specific logic to enable future chain additions
4. **Client-Side Transaction Routing**: Handle insufficient balance scenarios in the UI layer
5. **$250 Transaction Limit**: Enforce across all transaction types for MVP safety

### Profile-Centric Data Model

The system is built around a **Profile** as the central entity:

**Profile → Accounts (1:many)**
- Each profile has one **primary account** (smart wallet auto-generated by Privy during signup)
- Users can add multiple **external accounts** by connecting additional wallets (Base or Solana)
- Each account is linked to **account_transactions** table tracking all incoming/outgoing transactions

**Profile → Investments (1:many)**
- Profiles can have multiple investments (Morpho vault deposits)
- Each investment is linked to **investment_movements** table tracking deposits, withdrawals, rewards, and fees
- Investments are separate from accounts but can be funded from any account

**Profile → Recipients (1:many)**
- Users can save recipients for quick payments
- Recipients can be internal (other Banb users) or external (wallet addresses)

**Profile → Automation Rules (1:many)**
- Users can create automated financial rules
- Each rule tracks its executions in **automation_executions** table

**Profile → AI Operations (1:many)**
- All AI interactions are logged for audit trail

## Architecture

### High-Level System Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Frontend (Next.js)                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐│
│  │   Dashboard  │  │   Payments   │  │   Card +     │  │  Investments │││
│  │   Component  │  │   Component  │  │   Lending    │  │   Component  │││
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘│
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐│
│  │  AI Chat     │  │  Recipients  │  │  Add Account │  │  Analytics   │││
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘│
└─────────────────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        │                     │                     │
┌───────▼────────┐   ┌────────▼────────┐   ┌───────▼────────┐
│  Privy SDK     │   │  Supabase DB    │   │  AI Service    │
│  - Auth        │   │  (Profile-      │   │  - Analytics   │
│  - Wallets     │   │   Centric)      │   │  - Automation  │
│  - Multi-chain │   │                 │   │  - Chat        │
└────────┬───────┘   └────────┬────────┘   └────────────────┘
         │                    │
         │            ┌───────┴────────┐
         │            │                │
         │      ┌─────▼─────┐    ┌────▼────────┐
         │      │  Profile  │    │ AI Ops      │
         │      │  (1)      │    │ (1:many)    │
         │      └─────┬─────┘    └─────────────┘
         │            │
         │      ┌─────┴──────────────────┬──────────────┐
         │      │                        │              │
         │  ┌───▼────────┐        ┌──────▼──────────┐  │
         │  │  Accounts  │        │  Investments    │  │
         │  │  (1:many)  │        │  (1:many)       │  │
         │  │  - Primary │        │  - Morpho Vault │  │
         │  │  - External│        │                 │  │
         │  └─────┬──────┘        └──────┬──────────┘  │
         │        │                      │              │
         │  ┌─────▼──────────┐    ┌──────▼──────────┐  │
         │  │ Account        │    │ Investment      │  │
         │  │ Transactions   │    │ Movements       │  │
         │  │ (1:many)       │    │ (1:many)        │  │
         │  └────────────────┘    └─────────────────┘  │
         │                                              │
         │                                    ┌─────────▼────────┐
         │                                    │  Recipients      │
         │                                    │  (1:many)        │
         │                                    └──────────────────┘
         │
    ┌────┴────┐
    │         │
┌───▼───┐ ┌──▼────┐
│ Wagmi │ │Solana │
│ (EVM) │ │web3.js│
└───┬───┘ └──┬────┘
    │        │
    │        │
┌───▼────┐ ┌▼──────┐
│  Base  │ │Solana │
│ Mainnet│ │Mainnet│
└───┬────┘ └┬──────┘
    │       │
    │       │
┌───▼───────▼────────────────────┐
│  Bridge SDK (Wormhole/Allbridge)│
│  - Cross-chain USDC transfers   │
│  - Used when source & dest      │
│    chains differ                │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│   Lending Protocols              │
│   (NOT connected to Bridge)      │
│                                  │
│  ┌─────────┐    ┌──────────┐    │
│  │ Morpho  │    │ Kamino   │    │
│  │ (Base)  │    │ (Solana) │    │
│  │ Lending │    │ Lending  │    │
│  └─────────┘    └──────────┘    │
└─────────────────────────────────┘
```

### Data Model Relationships

```
Profile (Central Entity)
  │
  ├─── Accounts (1:many)
  │      │
  │      ├─── Primary Account (Smart Wallet from Privy)
  │      │      └─── Created automatically on signup
  │      │
  │      └─── External Accounts (Added by user)
  │             ├─── Base wallets
  │             ├─── Solana wallets
  │             └─── Each has Account Transactions (1:many)
  │
  ├─── Investments (1:many)
  │      │
  │      ├─── Morpho Vault deposits
  │      └─── Each has Investment Movements (1:many)
  │             ├─── Deposits
  │             ├─── Withdrawals
  │             ├─── Rewards
  │             └─── Fees
  │
  ├─── Recipients (1:many)
  │      ├─── Internal (other Banb users)
  │      └─── External (wallet addresses)
  │
  ├─── Automation Rules (1:many)
  │      └─── Each has Automation Executions (1:many)
  │
  └─── AI Operations (1:many)
```

### Technology Stack

- **Frontend**: Next.js 15.5.4, React 19, TypeScript 5
- **Authentication & Wallets**: Privy SDK (multi-chain support)
- **EVM Interactions**: Wagmi 2.17.5, Viem 2.38.0
- **Solana Interactions**: @solana/web3.js (via Privy SDK)
- **Database**: Supabase (PostgreSQL)
- **AI**: Existing chat module + OpenAI API
- **Lending Protocols**: Morpho (Base), Kamino (Solana)
- **Bridge**: Wormhole SDK or Allbridge Core SDK (to be evaluated)
- **UI**: Tailwind CSS, shadcn/ui (Radix UI)

### Existing Components (Already Implemented)

The following components are already in place and should be extended, not rebuilt:

1. **User Authentication & Profile Management**
   - Privy integration for email, X, and Farcaster login
   - User context provider (`lib/user-context.tsx`)
   - Profile creation and management (`lib/profile.ts`)

2. **Database Schema**
   - `profiles` table with user data
   - `accounts` table for wallet management
   - `account_transactions` table for transaction history
   - `recipients` table for saved payment recipients
   - `investments` table for Morpho vault deposits
   - `investment_movements` table for investment activity
   - `ai_operations` table for AI interaction logging

3. **Payment System**
   - Send USDC on Base (existing)
   - Recipient management
   - Transaction history display

4. **AI Chat Module**
   - Existing AI agent (`lib/ai-agent.ts`)
   - Chat UI component (`components/ai/AIAgentChat.tsx`)
   - Payment execution via AI

5. **Investment System**
   - Morpho vault integration (existing)
   - Investment tracking and display

**MVP v1 Additions**: The new work focuses on adding Solana support, cross-chain bridging, Kamino lending, enhanced AI analytics/automation, and card simulation to this existing foundation.

## Components and Interfaces

### 1. Multi-Chain Wallet Management

#### Account Creation Flow

**Signup Flow**:
1. User signs up via email, X, or Farcaster
2. Privy automatically creates an embedded EVM wallet (Primary_Wallet)
3. Banb creates a User_Profile in Supabase
4. Banb creates a primary account record in Supabase accounts table linked to the embedded wallet

**Add Spending Account Flow**:
1. User clicks "Add Account" from dashboard
2. User is prompted to connect an external wallet
3. User can choose to connect either:
   - An EVM wallet (Base, Ethereum, etc.)
   - A Solana wallet
4. After successful connection:
   - Wallet is linked to the user's Privy account
   - New account record is created in Supabase accounts table
   - Account is linked to the user's profile_id

**Data Retrieval**:
- Accounts are retrieved via Supabase API call (not from Privy's `useWallets()`)
- The accounts table serves as the source of truth for user's connected wallets
- Each account record includes: address, chain, type, and link to profile_id

#### Add Account UI Component

**Location**: `components/wallet/AddAccountModal.tsx`

**Purpose**: Allow users to connect additional wallets (EVM or Solana) to their profile

**Key Functions**:
```typescript
interface AddAccountModalProps {
  profileId: string;
  onAccountAdded: (account: Account) => void;
  onClose: () => void;
}

interface Account {
  id: string;
  profile_id: string;
  address: string;
  chain: 'base' | 'solana' | 'ethereum';
  type: 'spending' | 'investment' | 'savings';
  is_primary: boolean;
}
```

**Implementation Details**:
- Display "Connect Wallet" button that triggers Privy's wallet connection modal
- Privy modal allows user to select wallet type (EVM or Solana)
- After wallet connection in Privy, call Supabase API to create account record
- Link the new wallet address to the user's profile_id
- Refresh account list from Supabase after successful creation



### 2. Solana Integration - NEW

**Pattern**: Mirror the existing Base transaction pattern

**Reference**: https://docs.privy.io/wallets/using-wallets/solana/web3-integrations

#### Solana Transaction Service

**Location**: `lib/solana/transactions.ts`

**Purpose**: Database operations for Solana transactions (mirrors `lib/transactions.ts` for Base)

```typescript
import { supabase } from "./supabase";

/**
 * Creates a Solana transaction record in account_transactions table
 */
export async function createSolanaTransaction(data: {
  account_id: string;
  amount: string;
  direction: 'in' | 'out';
  counterparty?: string;
  counterparty_name?: string;
  token_symbol: string;
  description?: string;
}): Promise<AccountTransaction> {
  const { data: transaction, error } = await supabase
    .from('account_transactions')
    .insert({
      account_id: data.account_id,
      amount: data.amount,
      direction: data.direction,
      counterparty: data.counterparty,
      counterparty_name: data.counterparty_name,
      token_symbol: data.token_symbol,
      network: 'solana',
      status: 'pending',
      description: data.description
    })
    .select()
    .single();
    
  if (error) throw new Error(`Failed to create transaction: ${error.message}`);
  return transaction;
}

/**
 * Updates Solana transaction status and tx_hash
 */
export async function updateSolanaTransactionStatus(
  transactionId: string,
  status: 'pending' | 'confirmed' | 'failed',
  txSignature?: string
): Promise<AccountTransaction> {
  const updates: any = { status };
  if (txSignature) updates.tx_hash = txSignature;
  
  const { data, error } = await supabase
    .from('account_transactions')
    .update(updates)
    .eq('id', transactionId)
    .select()
    .single();
    
  if (error) throw new Error(`Failed to update transaction: ${error.message}`);
  return data;
}

/**
 * Gets Solana transactions for an account
 */
export async function getSolanaTransactions(
  accountId: string
): Promise<AccountTransaction[]> {
  const { data, error } = await supabase
    .from('account_transactions')
    .select('*')
    .eq('account_id', accountId)
    .eq('network', 'solana')
    .order('created_at', { ascending: false });
    
  if (error) throw new Error(`Failed to fetch transactions: ${error.message}`);
  return data || [];
}
```

#### Solana Payment Service

**Location**: `lib/solana/payments.ts`

**Purpose**: React hooks for executing Solana transactions (mirrors `lib/payments.ts` for Base)

```typescript
"use client";

import { useState, useCallback } from "react";
import { useWallets } from "@privy-io/react-auth";
import { Connection, PublicKey, Transaction } from "@solana/web3.js";
import { getAssociatedTokenAddress, createTransferInstruction } from "@solana/spl-token";
import { createSolanaTransaction, updateSolanaTransactionStatus } from "./transactions";

const USDC_MINT_ADDRESS = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"; // Solana mainnet USDC
const USDC_DECIMALS = 6;

export interface SolanaPaymentData {
  accountId: string;
  to: string;
  amount: string;
  counterpartyName?: string;
}

export interface SolanaPaymentResult {
  signature: string;
  txId: string;
  status: "pending" | "confirmed" | "failed";
}

/**
 * React hook for executing Solana USDC payments
 * Mirrors useCryptoPayment from lib/payments.ts
 */
export function useSolanaPayment() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { wallets } = useWallets();
  
  const executePayment = useCallback(
    async (data: SolanaPaymentData): Promise<SolanaPaymentResult> {
      // Find Solana wallet
      const solanaWallet = wallets.find(w => w.walletClientType === 'solana');
      if (!solanaWallet) {
        throw new Error("No Solana wallet connected");
      }
      
      setIsLoading(true);
      setError(null);
      
      try {
        // 1. Validate $250 limit
        if (parseFloat(data.amount) > 250) {
          throw new Error("Transaction exceeds $250 limit");
        }
        
        // 2. Create transaction record in DB
        const transaction = await createSolanaTransaction({
          account_id: data.accountId,
          amount: data.amount,
          direction: 'out',
          counterparty: data.to,
          counterparty_name: data.counterpartyName,
          token_symbol: 'USDC'
        });
        
        // 3. Build Solana transaction
        const connection = new Connection(
          process.env.NEXT_PUBLIC_SOLANA_RPC_URL || 
          "https://api.mainnet-beta.solana.com"
        );
        
        const fromPubkey = new PublicKey(solanaWallet.address);
        const toPubkey = new PublicKey(data.to);
        const mintPubkey = new PublicKey(USDC_MINT_ADDRESS);
        
        // Get associated token accounts
        const fromTokenAccount = await getAssociatedTokenAddress(mintPubkey, fromPubkey);
        const toTokenAccount = await getAssociatedTokenAddress(mintPubkey, toPubkey);
        
        // Create transfer instruction
        const amountInSmallestUnit = parseFloat(data.amount) * Math.pow(10, USDC_DECIMALS);
        const transferInstruction = createTransferInstruction(
          fromTokenAccount,
          toTokenAccount,
          fromPubkey,
          amountInSmallestUnit
        );
        
        // Build and send transaction via Privy
        const tx = new Transaction().add(transferInstruction);
        const { blockhash } = await connection.getLatestBlockhash();
        tx.recentBlockhash = blockhash;
        tx.feePayer = fromPubkey;
        
        // Sign and send via Privy wallet
        const signedTx = await solanaWallet.signTransaction(tx);
        const signature = await connection.sendRawTransaction(signedTx.serialize());
        
        // 4. Update transaction with signature
        await updateSolanaTransactionStatus(transaction.id, 'pending', signature);
        
        // 5. Wait for confirmation
        await connection.confirmTransaction(signature);
        await updateSolanaTransactionStatus(transaction.id, 'confirmed');
        
        return {
          signature,
          txId: transaction.id,
          status: 'confirmed'
        };
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Payment failed";
        setError(errorMessage);
        throw new Error(errorMessage);
      } finally {
        setIsLoading(false);
      }
    },
    [wallets]
  );
  
  return {
    executePayment,
    isLoading,
    error
  };
}

/**
 * Hook to get USDC balance for Solana wallet
 */
export function useSolanaUSDCBalance(address?: string) {
  const [balance, setBalance] = useState<string | undefined>();
  const [isLoading, setIsLoading] = useState(false);
  
  // Implementation similar to useUSDCBalance but for Solana
  // Query token account balance using @solana/web3.js
  
  return {
    formattedBalance: balance,
    isLoading,
    isError: false
  };
}
```

**Key Implementation Notes**:
- Use Privy's Solana wallet integration (see docs link above)
- Mirror the Base transaction flow: create DB record → execute blockchain tx → update status
- Use @solana/web3.js and @solana/spl-token for Solana operations
- Handle associated token accounts (USDC is SPL token)
- Reuse existing transaction modal UI components
- Follow same status lifecycle: pending → confirmed/failed

### 3. Insufficient Balance Handling (Simplified)

**Approach**: Show error message, let user manually resolve

**Location**: Existing transaction validation logic

**Purpose**: Notify user of insufficient funds and suggest resolution paths

**Implementation**:
```typescript
// In transaction validation
if (userBalance < requiredAmount) {
  throw new Error(
    `Insufficient balance. You need ${shortfall} more USDC. ` +
    `Move funds from another account or create an automation rule.`
  );
}
```

**User Resolution Options**:
1. **Manual Move**: Navigate to Move page and transfer funds from another account
2. **Automation Rule**: Create rule via AI chat (e.g., "create rule: if balance < $10, transfer from account X")

**No Complex UI**: Keep it simple - just show error and let user choose their preferred resolution method

### 4. Move Funds Component - NEW

#### Move Page

**Location**: `/app/move/page.tsx`

**Purpose**: Allow users to move USDC between their own accounts (same-chain or cross-chain)

**Entry Point**: "Move" button on each account card

**URL Parameters**:
```typescript
// Navigate with source account ID
router.push(`/move?source=${accountId}`);
```

**Component Structure**:
```typescript
interface MovePageProps {
  searchParams: { source?: string };
}

export default function MovePage({ searchParams }: MovePageProps) {
  const sourceAccountId = searchParams.source;
  const [destinationAccountId, setDestinationAccountId] = useState<string>('');
  
  // Fetch source account details
  // Fetch user's other accounts for destination dropdown
  // Detect if bridge is needed (source.network !== destination.network)
  // Reuse existing transaction modal for amount input and execution
}
```

**UI Flow**:
1. **Source Account Display**: Show fixed source account (name, balance, network)
2. **Destination Dropdown**: List all user's accounts except source
3. **Bridge Indicator**: If chains differ, show "Cross-chain transfer via bridge" badge
4. **Amount Input**: Reuse existing transaction modal component
5. **Review & Execute**: Standard transaction flow

**Bridge Detection Logic**:
```typescript
function detectBridgeNeed(sourceAccount: Account, destAccount: Account): boolean {
  return sourceAccount.network !== destAccount.network;
}

async function executeMove(params: {
  sourceAccountId: string;
  destinationAccountId: string;
  amount: string;
}) {
  const source = await getAccount(params.sourceAccountId);
  const dest = await getAccount(params.destinationAccountId);
  
  if (detectBridgeNeed(source, dest)) {
    // Execute bridge transaction
    return executeBridge({
      sourceChain: source.network,
      destinationChain: dest.network,
      sourceAddress: source.address,
      destinationAddress: dest.address,
      amount: params.amount
    });
  } else {
    // Execute standard transfer
    return executeTransfer({
      from: source.address,
      to: dest.address,
      amount: params.amount,
      network: source.network
    });
  }
}
```

**Database Recording**:
```typescript
// Create TWO records in account_transactions
await createAccountTransaction({
  account_id: sourceAccountId,
  amount: amount,
  direction: 'out',
  counterparty: destinationAccount.address,
  counterparty_name: destinationAccount.name,
  tx_hash: txHash,
  token_symbol: 'USDC',
  network: sourceAccount.network,
  status: 'pending',
  description: isBridge ? 'bridge' : 'internal_transfer',
  metadata: isBridge ? {
    bridge_provider: 'wormhole',
    destination_chain: destinationAccount.network,
    bridge_fee: fee
  } : null
});

await createAccountTransaction({
  account_id: destinationAccountId,
  amount: amount,
  direction: 'in',
  counterparty: sourceAccount.address,
  counterparty_name: sourceAccount.name,
  tx_hash: destTxHash,
  token_symbol: 'USDC',
  network: destinationAccount.network,
  status: 'pending',
  description: isBridge ? 'bridge' : 'internal_transfer',
  metadata: isBridge ? {
    bridge_provider: 'wormhole',
    source_chain: sourceAccount.network
  } : null
});
```

### 5. Cross-Chain Bridging

**Important**: The bridge is used exclusively for moving USDC between Base and Solana chains. It is **not connected** to lending protocols (Morpho/Kamino). Lending protocols are separate systems where users deposit collateral and borrow USDC on a single chain.

**Bridge Use Case**: Transfer USDC from user's Base account to user's Solana account (or vice versa)

**Lending Use Case**: Deposit ETH collateral on Base → Borrow USDC on Base (via Morpho)

#### Bridge Service

**Location**: `lib/bridge/index.ts`

**Purpose**: Abstract bridge SDK operations for cross-chain USDC transfers

```typescript
interface BridgeParams {
  sourceChain: 'base' | 'solana';
  destinationChain: 'base' | 'solana';
  sourceAddress: string;
  destinationAddress: string;
  amount: string;
  token: 'USDC';
}

interface BridgeQuote {
  estimatedFee: string;
  estimatedTime: number; // seconds
  route: string;
}

interface BridgeStatus {
  status: 'sent' | 'bridging' | 'completed' | 'failed';
  sourceTxHash?: string;
  destinationTxHash?: string;
  progress: number; // 0-100
}

export class BridgeService {
  async getQuote(params: BridgeParams): Promise<BridgeQuote>;
  async executeBridge(params: BridgeParams): Promise<string>;
  async getStatus(bridgeId: string): Promise<BridgeStatus>;
}
```

**Implementation Options**:

**Option A: Wormhole SDK**
```typescript
import { Wormhole } from "@wormhole-foundation/sdk";

// Pros: Well-established, good documentation
// Cons: May have higher fees
```

**Option B: Allbridge Core SDK**
```typescript
import { AllbridgeCoreSdk } from "@allbridge/bridge-core-sdk";

// Pros: Lower fees, simpler API
// Cons: Less documentation
```

**Decision**: Evaluate both during implementation, prioritize ease of integration and no-iframe requirement

#### Bridge Trigger Scenarios

**Scenario 1: Manual Move (via /app/move/page.tsx)**
- User clicks "Move" on account card
- Selects destination account on different chain
- Bridge automatically triggered
- Uses existing transaction modal UI

**Scenario 2: Automated via Programmable Rules**
- Rule condition met (e.g., "if main account < $10, transfer from highest balance account")
- System identifies highest balance account is on different chain
- Bridge automatically triggered
- Execution logged in ai_operations table

#### Bridge Detection Logic

**Location**: `lib/bridge/detector.ts`

```typescript
export function shouldUseBridge(
  sourceNetwork: string,
  destinationNetwork: string
): boolean {
  return sourceNetwork !== destinationNetwork;
}

export async function executeTransferWithBridgeDetection(params: {
  sourceAccountId: string;
  destinationAccountId: string;
  amount: string;
}) {
  const source = await getAccount(params.sourceAccountId);
  const dest = await getAccount(params.destinationAccountId);
  
  if (shouldUseBridge(source.network, dest.network)) {
    return await executeBridgeTransfer({
      ...params,
      sourceChain: source.network,
      destinationChain: dest.network,
      sourceAddress: source.address,
      destinationAddress: dest.address
    });
  } else {
    return await executeSameChainTransfer({
      ...params,
      network: source.network,
      from: source.address,
      to: dest.address
    });
  }
}
```

#### Bridge Transaction Recording

**No separate bridge_transactions table** - Use account_transactions with metadata:

```typescript
// Source account record
{
  account_id: sourceAccountId,
  amount: amount,
  direction: 'out',
  description: 'bridge',
  metadata: {
    bridge_provider: 'wormhole',
    destination_chain: 'solana',
    source_chain: 'base',
    bridge_fee: '0.50',
    estimated_time: 300
  }
}

// Destination account record
{
  account_id: destinationAccountId,
  amount: amount,
  direction: 'in',
  description: 'bridge',
  metadata: {
    bridge_provider: 'wormhole',
    source_chain: 'base',
    destination_chain: 'solana'
  }
}
```

**Features**:
- Automatic bridge detection based on network mismatch
- Display estimated bridge fee in review step
- Show estimated completion time (e.g., "~2-5 minutes")
- Single unified transaction experience
- $250 limit enforcement (same as regular transactions)
- Works for both manual moves and automated rules



### 5. Lending Integration

#### Morpho Lending Service (Base)

**Location**: `lib/lending/morpho.ts`

**Purpose**: Interface with Morpho protocol on Base

```typescript
interface MorphoPosition {
  collateralAmount: string;
  collateralToken: 'WETH' | 'stETH' | 'cbBTC';
  borrowedAmount: string;
  borrowToken: 'USDC';
  apr: number;
  collateralRatio: number;
  liquidationThreshold: number;
}

export class MorphoService {
  private contract: Contract; // Wagmi contract instance
  
  async getMarketData(): Promise<{
    apr: number;
    availableLiquidity: string;
    supportedCollaterals: string[];
  }>;
  
  async depositCollateral(params: {
    token: 'WETH' | 'stETH' | 'cbBTC';
    amount: string;
    userAddress: string;
  }): Promise<string>;
  
  async borrow(params: {
    amount: string;
    userAddress: string;
  }): Promise<string>;
  
  async repay(params: {
    amount: string;
    userAddress: string;
  }): Promise<string>;
  
  async withdrawCollateral(params: {
    token: 'WETH' | 'stETH' | 'cbBTC';
    amount: string;
    userAddress: string;
  }): Promise<string>;
  
  async getPosition(userAddress: string): Promise<MorphoPosition>;
}
```

**Key Implementation Details**:
- Use Wagmi's `useWriteContract` for transactions
- Fetch APR from Morpho API or on-chain data
- Calculate collateral ratio in real-time
- Enforce $250 limit on all operations
- Handle approval transactions for ERC20 collateral

#### Kamino Lending Service (Solana)

**Location**: `lib/lending/kamino.ts`

**Purpose**: Interface with Kamino protocol on Solana

```typescript
interface KaminoPosition {
  collateralAmount: string;
  collateralToken: 'SOL';
  borrowedAmount: string;
  borrowToken: 'USDC';
  apr: number;
  collateralRatio: number;
  liquidationThreshold: number;
}

export class KaminoService {
  private connection: Connection;
  
  async getMarketData(): Promise<{
    apr: number;
    availableLiquidity: string;
  }>;
  
  async depositCollateral(params: {
    amount: string;
    userAddress: string;
    wallet: any; // Privy wallet
  }): Promise<string>;
  
  async borrow(params: {
    amount: string;
    userAddress: string;
    wallet: any;
  }): Promise<string>;
  
  async repay(params: {
    amount: string;
    userAddress: string;
    wallet: any;
  }): Promise<string>;
  
  async withdrawCollateral(params: {
    amount: string;
    userAddress: string;
    wallet: any;
  }): Promise<string>;
  
  async getPosition(userAddress: string): Promise<KaminoPosition>;
}
```



### 6. Virtual Card + Lending Combined UI - NEW

**Location**: Update existing card component

**Purpose**: Single page showing spendable balance (USDC + borrowable) with lending management

#### Page Layout

```
┌─────────────────────────────────────┐
│     Virtual Card Visual             │
│  ┌───────────────────────────────┐  │
│  │  BANB                         │  │
│  │                               │  │
│  │  Available to Spend           │  │
│  │  $1,250.00                    │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘

Available to Spend: $1,250.00

┌─────────────────────────────────────┐
│ Available USDC: $1,000.00           │
│ [Details ▼]                         │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ Borrowed USDC: $250.00              │
│ [Details ▼]                         │
└─────────────────────────────────────┘

[Pay with Card] (Simulation)

Simulated Transactions:
- Starbucks: $5.50
- Amazon: $45.00
```

#### Component Structure

**Location**: `app/card/page.tsx` or `components/card/CardPage.tsx`

```typescript
export function CardPage() {
  const [availableUSDC, setAvailableUSDC] = useState<string>('0');
  const [borrowedUSDC, setBorrowedUSDC] = useState<string>('0');
  const [lendingPosition, setLendingPosition] = useState<LendingPosition | null>(null);
  const [showAvailableDetails, setShowAvailableDetails] = useState(false);
  const [showBorrowedDetails, setShowBorrowedDetails] = useState(false);
  
  // Fetch lending position on mount and freeze until refresh
  useEffect(() => {
    fetchLendingPosition().then(setLendingPosition);
  }, []);
  
  // Calculate total available to spend
  const totalAvailable = parseFloat(availableUSDC) + parseFloat(borrowedUSDC);
  
  return (
    <div>
      {/* Virtual Card Display */}
      <VirtualCard totalAvailable={totalAvailable} />
      
      {/* Available to Spend Header */}
      <h2>Available to Spend: ${totalAvailable.toFixed(2)}</h2>
      
      {/* Available USDC Section */}
      <Section>
        <SectionHeader>
          Available USDC: ${availableUSDC}
          <button onClick={() => setShowAvailableDetails(!showAvailableDetails)}>
            Details {showAvailableDetails ? '▲' : '▼'}
          </button>
        </SectionHeader>
        {showAvailableDetails && (
          <div>
            <p>Your current USDC balance across all accounts</p>
            {/* List accounts with balances */}
          </div>
        )}
      </Section>
      
      {/* Borrowed USDC Section */}
      <Section>
        <SectionHeader>
          Borrowed USDC: ${borrowedUSDC}
          <button onClick={() => setShowBorrowedDetails(!showBorrowedDetails)}>
            Details {showBorrowedDetails ? '▲' : '▼'}
          </button>
        </SectionHeader>
        {showBorrowedDetails && lendingPosition && (
          <LendingPositionDetails 
            position={lendingPosition}
            onBorrowMore={handleBorrowMore}
            onRepay={handleRepay}
            onWithdraw={handleWithdraw}
          />
        )}
      </Section>
      
      {/* Simulated Spending */}
      <button onClick={handleSimulatePayment}>Pay with Card</button>
      <SimulatedTransactionsList />
      <p className="disclaimer">Test mode — No real money spent</p>
    </div>
  );
}
```

#### Lending Position Details Component

```typescript
interface LendingPositionDetailsProps {
  position: LendingPosition;
  onBorrowMore: () => void;
  onRepay: () => void;
  onWithdraw: () => void;
}

function LendingPositionDetails({ position, onBorrowMore, onRepay, onWithdraw }: LendingPositionDetailsProps) {
  return (
    <div className="lending-details">
      <h3>Your Lending Position</h3>
      
      <div className="position-summary">
        <div>
          <label>Collateral</label>
          <p>{position.collateralAmount} {position.collateralToken}</p>
        </div>
        <div>
          <label>Borrowed</label>
          <p>{position.borrowedAmount} USDC</p>
        </div>
        <div>
          <label>APR</label>
          <p>{position.apr}%</p>
        </div>
        <div>
          <label>Collateral Ratio</label>
          <p>{position.collateralRatio}%</p>
        </div>
      </div>
      
      <div className="actions">
        <button onClick={onBorrowMore}>Borrow More USDC</button>
        <button onClick={onRepay}>Repay</button>
        <button onClick={onWithdraw}>Withdraw Collateral</button>
      </div>
      
      <CollateralOptions 
        availableCollaterals={['WETH', 'stETH', 'cbBTC', 'SOL']}
        onSelectCollateral={handleCollateralSelect}
      />
    </div>
  );
}
```

#### Data Fetching Strategy

**Lending Position Query**:
```typescript
async function fetchLendingPosition(): Promise<LendingPosition> {
  // Query Morpho API for Base positions
  const morphoPosition = await queryMorphoPosition(userAddress);
  
  // Query Kamino API for Solana positions
  const kaminoPosition = await queryKaminoPosition(userAddress);
  
  // Combine and return
  return {
    ...morphoPosition,
    ...kaminoPosition
  };
}
```

**Caching Strategy**:
- Use React Query with `staleTime: Infinity` to freeze data while modal is open
- Refetch on:
  - Page mount/refresh
  - After borrow/repay/withdraw action completes
  - User navigates away and returns

**Simulated Transactions** (Memory Only):
```typescript
// In-memory storage (cleared on page refresh)
let simulatedTransactions: SimulatedTransaction[] = [];

export function simulatePayment(params: {
  amount: string;
  merchant: string;
  category: string;
}): SimulatedTransaction {
  const tx: SimulatedTransaction = {
    id: crypto.randomUUID(),
    amount: params.amount,
    merchant: params.merchant,
    category: params.category,
    timestamp: Date.now()
  };
  simulatedTransactions.push(tx);
  return tx;
}
```

**Key Features**:
- Single page combining card visual and lending management
- Collapsible sections for Available USDC and Borrowed USDC
- Lending position details only shown when user expands "Borrowed USDC"
- Real borrowing operations (blockchain transactions)
- Simulated spending (memory only, no blockchain)
- Data frozen until user refreshes or performs action

### 7. AI-Powered Analytics

#### Analytics Query Service

**Location**: `lib/ai/analytics.ts`

**Purpose**: Process spending analytics queries

```typescript
interface SpendingAnalytics {
  totalSpent: string;
  period: 'day' | 'week' | 'month';
  byCategory: Record<string, string>;
  byRecipient: Record<string, string>;
  topSpending: {
    category: string;
    amount: string;
    percentage: number;
  };
  savingOpportunities: {
    category: string;
    potentialSavings: string;
    suggestion: string;
  }[];
}

export class AnalyticsService {
  async getSpendingAnalytics(params: {
    profileId: string;
    period: 'day' | 'week' | 'month';
  }): Promise<SpendingAnalytics>;
  
  async analyzeSpendingPatterns(profileId: string): Promise<{
    insights: string[];
    recommendations: string[];
  }>;
  
  async getSavingSuggestions(profileId: string): Promise<{
    category: string;
    currentSpending: string;
    suggestedLimit: string;
    potentialSavings: string;
  }[]>;
}
```

**Query Processing Flow**:
1. User asks question in AI chat
2. AI service identifies query type (spending analytics)
3. Extract parameters (time period, category, etc.)
4. Query Supabase account_transactions table
5. Aggregate data across all user accounts and chains
6. Format response with numeric summaries
7. Return conversational response with insights

**Supported Query Types**:
- "How much did I spend this week?"
- "Where do I spend the most?"
- "How much am I spending per category?"
- "How can I save most?"
- "What's my borrow APR?"
- "How much USDC left to repay?"

### 8. AI-Powered Automation

#### Automation Rules Engine

**Location**: `lib/ai/automation.ts`

**Purpose**: Define and execute automated financial rules

```typescript
interface AutomationRule {
  id: string;
  profileId: string;
  name: string;
  condition: RuleCondition;
  action: RuleAction;
  enabled: boolean;
  lastExecuted: string | null;
  executionCount: number;
}

interface RuleCondition {
  type: 'balance_below' | 'balance_above' | 'investment_return' | 'spending_limit';
  accountId?: string;
  threshold: string;
  token: string;
}

interface RuleAction {
  type: 'transfer' | 'withdraw' | 'notify';
  fromAccountId?: string;
  toAccountId?: string;
  amount?: string;
  message?: string;
}

export class AutomationEngine {
  async createRule(rule: Omit<AutomationRule, 'id'>): Promise<AutomationRule>;
  
  async evaluateRules(profileId: string): Promise<void>;
  
  async executeRule(ruleId: string): Promise<{
    success: boolean;
    txHash?: string;
    error?: string;
  }>;
  
  async getRules(profileId: string): Promise<AutomationRule[]>;
  
  async updateRule(ruleId: string, updates: Partial<AutomationRule>): Promise<void>;
  
  async deleteRule(ruleId: string): Promise<void>;
}
```

**Rule Examples**:
1. "If balance goes below $10, transfer $50 from savings account"
2. "If investment generates $10, withdraw and send to spending account"
3. "If spending in 'dining' exceeds $100/week, notify me"

**Execution Strategy**:
- Periodic evaluation (every 5 minutes via cron job or webhook)
- Event-driven evaluation (on transaction completion)
- Respect $250 transaction limit
- Log all automated actions
- Notify user of executed actions

#### AI Rules Management UI

**Location**: Extend existing AI section (same path, different tab view)

**UI Structure**:
```typescript
// In AI section component
const [activeTab, setActiveTab] = useState<'chat' | 'rules'>('chat');

return (
  <div>
    {/* Tab Navigation */}
    <div className="tabs">
      <button onClick={() => setActiveTab('chat')}>AI Chat</button>
      <button onClick={() => setActiveTab('rules')}>AI Rules</button>
    </div>
    
    {/* Content */}
    {activeTab === 'chat' && <AIChat />}
    {activeTab === 'rules' && <AutomationRulesManager />}
  </div>
);
```

**AutomationRulesManager Component**:

**Location**: `components/ai/AutomationRulesManager.tsx`

```typescript
interface AutomationRule {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  last_executed_at: string | null;
  execution_count: number;
}

export function AutomationRulesManager() {
  const [rules, setRules] = useState<AutomationRule[]>([]);
  
  return (
    <div>
      <h2>Your Automation Rules</h2>
      <p>Create rules via AI chat. Manage them here.</p>
      
      {rules.length === 0 && (
        <EmptyState>
          <p>No rules yet. Try asking AI:</p>
          <code>"Create rule: if balance &lt; $10, transfer from savings"</code>
        </EmptyState>
      )}
      
      {rules.map(rule => (
        <RuleCard key={rule.id}>
          <div>
            <h3>{rule.name}</h3>
            <p>{rule.description}</p>
            <small>
              Executed {rule.execution_count} times
              {rule.last_executed_at && ` • Last: ${formatDate(rule.last_executed_at)}`}
            </small>
          </div>
          
          <div className="actions">
            {/* Pause/Resume Toggle */}
            <button onClick={() => toggleRule(rule.id, !rule.enabled)}>
              {rule.enabled ? 'Pause' : 'Resume'}
            </button>
            
            {/* Delete Button */}
            <button onClick={() => deleteRule(rule.id)} className="danger">
              Delete
            </button>
          </div>
        </RuleCard>
      ))}
      
      <HelpText>
        To edit rule parameters, use AI chat. Example:
        "Update my savings rule to transfer when balance is below $20"
      </HelpText>
    </div>
  );
}
```

**Features**:
- **View Only**: Display all rules with status
- **Quick Actions**: Pause/Resume and Delete buttons only
- **No Manual Editing**: Parameters can only be changed via AI chat
- **Execution History**: Show count and last execution time
- **Empty State**: Guide users to create rules via AI chat
- **Help Text**: Remind users to use AI chat for editing

**Rule Creation Flow** (via AI Chat):
1. User types: "create rule: if balance < $10, transfer $50 from savings"
2. AI parses intent and parameters
3. AI confirms with user: "I'll create a rule to transfer $50 from your Savings account when your main balance drops below $10. Confirm?"
4. User confirms
5. Rule created in automation_rules table
6. Rule appears in "AI Rules" tab

## Data Models

### Existing Database Schema

The following tables are already implemented and form the core of the profile-centric architecture:

#### profiles table (existing)
```sql
-- Central entity for each user
CREATE TABLE profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  handle VARCHAR(50) UNIQUE NOT NULL,
  wallet_address VARCHAR(255) NOT NULL, -- Primary wallet from Privy
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### accounts table (existing)
```sql
-- Each profile has multiple accounts (wallets)
-- Primary account created on signup, external accounts added by user
CREATE TABLE accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id),
  name VARCHAR(255) NOT NULL,
  type VARCHAR(20) NOT NULL, -- 'spending', 'investment', 'savings'
  address VARCHAR(255) NOT NULL,
  network VARCHAR(50) NOT NULL, -- 'base', 'ethereum', 'polygon'
  balance NUMERIC(20, 8) DEFAULT 0,
  is_primary BOOLEAN DEFAULT false,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### account_transactions table (existing)
```sql
-- Each account has many transactions
CREATE TABLE account_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  account_id UUID NOT NULL REFERENCES accounts(id),
  amount NUMERIC(20, 8) NOT NULL,
  direction VARCHAR(10) NOT NULL, -- 'in', 'out'
  counterparty VARCHAR(255),
  counterparty_name VARCHAR(255),
  tx_hash VARCHAR(255),
  token_symbol VARCHAR(10) NOT NULL,
  network VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL, -- 'pending', 'confirmed', 'failed'
  description TEXT,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### investments table (existing)
```sql
-- Each profile can have multiple investments (Morpho vaults)
CREATE TABLE investments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id),
  investment_name VARCHAR(255) NOT NULL,
  investment_type VARCHAR(50) NOT NULL, -- 'morpho_vault', 'savings_account'
  vault_address VARCHAR(255),
  amount_invested NUMERIC(20, 8) DEFAULT 0,
  current_rewards NUMERIC(20, 8) DEFAULT 0,
  apr NUMERIC(5, 2),
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### investment_movements table (existing)
```sql
-- Each investment has many movements
CREATE TABLE investment_movements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id),
  investment_id UUID NOT NULL REFERENCES investments(id),
  movement_type VARCHAR(20) NOT NULL, -- 'deposit', 'withdrawal', 'reward', 'fee'
  amount NUMERIC(20, 8) NOT NULL,
  token VARCHAR(10) NOT NULL,
  tx_hash VARCHAR(255),
  chain VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### recipients table (existing)
```sql
-- Saved payment recipients for each profile
CREATE TABLE recipients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id),
  name VARCHAR(255) NOT NULL,
  status VARCHAR(20) DEFAULT 'active',
  recipient_type VARCHAR(20) NOT NULL, -- 'crypto', 'bank'
  profile_id_link UUID REFERENCES profiles(id), -- If internal user
  external_address VARCHAR(255), -- If external wallet
  bank_details JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### ai_operations table (existing)
```sql
-- AI interaction audit trail
CREATE TABLE ai_operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id),
  operation_type VARCHAR(50) NOT NULL, -- 'payment', 'analysis', 'query'
  operation_data JSONB NOT NULL,
  user_message TEXT NOT NULL,
  ai_response TEXT NOT NULL,
  user_confirmed BOOLEAN DEFAULT false,
  executed BOOLEAN DEFAULT false,
  execution_result JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### New Database Schema for MVP v1

#### accounts table (modifications to existing)

```sql
ALTER TABLE accounts ADD COLUMN IF NOT EXISTS chain VARCHAR(20) DEFAULT 'base';
-- Values: 'base', 'solana', 'ethereum', etc.

-- Add index for chain queries
CREATE INDEX IF NOT EXISTS idx_accounts_chain ON accounts(chain);
CREATE INDEX IF NOT EXISTS idx_accounts_profile_chain ON accounts(profile_id, chain);
```

#### account_transactions table (existing, with additions)

```sql
ALTER TABLE account_transactions 
ADD COLUMN IF NOT EXISTS category VARCHAR(50),
ADD COLUMN IF NOT EXISTS is_automated BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS automation_rule_id UUID REFERENCES automation_rules(id);

-- Add index for analytics queries
CREATE INDEX IF NOT EXISTS idx_account_transactions_created_at 
ON account_transactions(account_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_account_transactions_category 
ON account_transactions(account_id, category);
```

### Database Schema Strategy for MVP v1

#### Use Existing Tables

**Primary Transaction Table**: `account_transactions`
- Use for ALL transaction types:
  - External payments (send USDC to others)
  - Internal transfers (between own accounts, same chain)
  - Bridge operations (between own accounts, different chains)
  - Lending operations (borrow, repay - optional)

**Transaction Recording Patterns**:

1. **Bridge Transactions**:
```sql
-- Source account record
INSERT INTO account_transactions (
  account_id, amount, direction, description, network, metadata
) VALUES (
  source_account_id, '100', 'out', 'bridge', 'base',
  '{"bridge_provider": "wormhole", "destination_chain": "solana", "bridge_fee": "0.50"}'
);

-- Destination account record
INSERT INTO account_transactions (
  account_id, amount, direction, description, network, metadata
) VALUES (
  dest_account_id, '99.50', 'in', 'bridge', 'solana',
  '{"bridge_provider": "wormhole", "source_chain": "base"}'
);
```

2. **Internal Transfers** (same chain):
```sql
-- Source account
INSERT INTO account_transactions (
  account_id, amount, direction, description, counterparty, counterparty_name
) VALUES (
  source_account_id, '100', 'out', 'internal_transfer', 
  dest_account_address, 'My Savings Account'
);

-- Destination account
INSERT INTO account_transactions (
  account_id, amount, direction, description, counterparty, counterparty_name
) VALUES (
  dest_account_id, '100', 'in', 'internal_transfer',
  source_account_address, 'My Spending Account'
);
```

3. **Lending Operations** (optional - can also use investment_movements):
```sql
-- Borrow USDC
INSERT INTO account_transactions (
  account_id, amount, direction, description, network, metadata
) VALUES (
  account_id, '200', 'in', 'borrow', 'base',
  '{"protocol": "morpho", "collateral_token": "WETH", "collateral_amount": "0.1"}'
);

-- Repay USDC
INSERT INTO account_transactions (
  account_id, amount, direction, description, network, metadata
) VALUES (
  account_id, '200', 'out', 'repay', 'base',
  '{"protocol": "morpho"}'
);
```

#### Deprecated/Unused Tables

**DO NOT USE**:
- `transactions` table - Legacy, being phased out
- `bridge_transactions` table - Not needed, use account_transactions
- `lending_positions` table - Not needed, query from protocol APIs
- `lending_transactions` table - Not needed, use account_transactions or investment_movements
- `card_simulations` table - Not needed, simulations are memory-only

#### Lending Position Queries

**Strategy**: Query directly from protocol APIs/contracts (no database cache)

**Benefits**:
- Always up-to-date with on-chain state
- No sync issues between database and blockchain
- Simpler architecture with fewer tables to maintain
- Single source of truth (the blockchain)

**Implementation**:
```typescript
// Query Morpho position
async function getMorphoPosition(userAddress: string): Promise<MorphoPosition> {
  // Call Morpho API or read from contract
  const position = await morphoContract.getPosition(userAddress);
  return {
    collateralAmount: position.collateral,
    collateralToken: position.collateralToken,
    borrowedAmount: position.debt,
    apr: position.borrowRate,
    collateralRatio: calculateRatio(position)
  };
}

// Query Kamino position
async function getKaminoPosition(userAddress: string): Promise<KaminoPosition> {
  // Call Kamino API or read from program
  // Similar to Morpho
}
```

#### Automation Rules

**New Table**: `automation_rules`
```sql
CREATE TABLE automation_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  condition_type VARCHAR(50) NOT NULL,
  condition_params JSONB NOT NULL,
  action_type VARCHAR(50) NOT NULL,
  action_params JSONB NOT NULL,
  enabled BOOLEAN DEFAULT true,
  last_executed_at TIMESTAMPTZ,
  execution_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
```

**Execution Logging**: Reuse `ai_operations` table
```sql
-- When automation rule executes
INSERT INTO ai_operations (
  profile_id, operation_type, operation_data, 
  user_message, ai_response, executed, execution_result
) VALUES (
  profile_id, 'automation',
  '{"rule_id": "uuid", "condition_met": "balance_below_threshold"}',
  'Rule: Transfer $50 when balance < $10',
  'Transferred $50 from Savings to Spending',
  true,
  '{"tx_hash": "0x...", "success": true}'
);
```

#### automation_rules table (new)

```sql
CREATE TABLE automation_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  profile_id UUID NOT NULL REFERENCES profiles(id),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  condition_type VARCHAR(50) NOT NULL, -- 'balance_below', 'balance_above', etc.
  condition_params JSONB NOT NULL,
  action_type VARCHAR(50) NOT NULL, -- 'transfer', 'withdraw', 'notify'
  action_params JSONB NOT NULL,
  enabled BOOLEAN DEFAULT true,
  last_executed_at TIMESTAMP WITH TIME ZONE,
  execution_count INTEGER DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_automation_rules_profile ON automation_rules(profile_id);
CREATE INDEX idx_automation_rules_enabled ON automation_rules(enabled);
```

**Note on Automation Executions**: Reuse the existing `ai_operations` table to track automation rule executions. When an automation rule executes:
- Create a record in `ai_operations` with:
  - operation_type='automation'
  - operation_data includes rule_id, condition met, action taken
  - user_message describes the rule trigger
  - ai_response describes the action executed
  - executed=true, execution_result includes tx_hash and success status
- This consolidates all AI-driven operations (chat, analytics, automation) in one table
- Simplifies querying and maintains consistency with existing AI operation logging

**Note on Card Simulations**: No database table needed. Simulated transactions are stored in memory only and cleared on page refresh. This is intentional as they are fake transactions for visualization purposes only.



## Error Handling

### Transaction Error Handling

**Strategy**: Provide clear, actionable error messages for all failure scenarios

#### Common Error Scenarios

1. **Insufficient Balance**
   - Detection: Before transaction submission
   - Response: Show InsufficientBalanceModal with routing options
   - Recovery: Switch wallet or transfer funds

2. **Transaction Limit Exceeded**
   - Detection: Before transaction submission
   - Response: Show error with limit ($250) and attempted amount
   - Recovery: Reduce amount or split into multiple transactions

3. **Network Errors**
   - Detection: During transaction submission
   - Response: Show retry option with exponential backoff
   - Recovery: Retry up to 3 times, then suggest manual retry

4. **Wallet Connection Errors**
   - Detection: During wallet interaction
   - Response: Show troubleshooting steps (check wallet extension, network, etc.)
   - Recovery: Reconnect wallet

5. **Bridge Failures**
   - Detection: During bridge execution or status polling
   - Response: Show bridge status with support contact
   - Recovery: Manual intervention may be required

6. **Lending Protocol Errors**
   - Detection: During protocol interaction
   - Response: Show protocol-specific error (insufficient collateral, etc.)
   - Recovery: Adjust parameters and retry

### Error Logging

**Location**: `lib/errors/logger.ts`

**Purpose**: Log errors for debugging and support

```typescript
interface ErrorLog {
  id: string;
  profileId: string;
  errorType: string;
  errorMessage: string;
  context: Record<string, any>;
  timestamp: number;
}

export class ErrorLogger {
  async logError(error: Error, context: Record<string, any>): Promise<void>;
  async getErrors(profileId: string): Promise<ErrorLog[]>;
}
```

**Storage**: Use console logging and external monitoring service (e.g., Sentry) instead of Supabase table. Rationale:
- Errors are transient and don't need long-term database storage
- External monitoring tools provide better error tracking, alerting, and debugging
- Reduces database complexity and storage costs
- Sentry/similar services offer better error grouping and analysis

## Testing Strategy

### Unit Testing

**Framework**: Jest + React Testing Library

**Coverage Areas**:
1. Chain adapters (Base and Solana)
2. Transaction services
3. Bridge service
4. Lending services (Morpho and Kamino)
5. Analytics service
6. Automation engine
7. Utility functions

**Example Test**:
```typescript
describe('SolanaTransactionService', () => {
  it('should enforce $250 transaction limit', async () => {
    const service = new SolanaTransactionService();
    await expect(
      service.sendUSDC({
        from: 'address1',
        to: 'address2',
        amount: '300',
        wallet: mockWallet
      })
    ).rejects.toThrow('Transaction exceeds $250 limit');
  });
});
```

### Integration Testing

**Focus**: Test interactions between components

**Key Integration Tests**:
1. Privy wallet connection → Supabase account creation
2. Transaction submission → Database record creation
3. Bridge execution → Status updates
4. Automation rule trigger → Action execution
5. AI query → Analytics data retrieval

### End-to-End Testing

**Framework**: Playwright or Cypress

**Critical User Flows**:
1. Sign up → Connect wallet → View dashboard
2. Add Solana wallet → Send USDC → Verify transaction
3. Insufficient balance → Switch wallet → Complete transaction
4. Bridge USDC Base → Solana → Verify completion
5. Deposit collateral → Borrow USDC → View position
6. Create automation rule → Trigger condition → Verify execution
7. Ask AI question → Receive analytics → View insights

### Manual Testing Checklist

**Pre-Launch Verification**:
- [ ] All chains connect successfully
- [ ] Transactions execute on mainnet with $250 limit
- [ ] Bridge completes cross-chain transfers
- [ ] Lending positions display correctly
- [ ] AI analytics return accurate data
- [ ] Automation rules execute as expected
- [ ] Card simulation works without real transactions
- [ ] Error messages are clear and helpful
- [ ] UI is responsive on mobile devices
- [ ] All transaction history displays correctly

## Security Considerations

### Transaction Security

1. **Amount Validation**
   - Validate all amounts client-side as user types
   - Enforce $250 limit in real-time during amount input
   - Show error immediately if amount exceeds limit
   - Prevent negative amounts or zero transfers
   - Disable submit button until valid amount is entered

2. **Address Validation**
   - Validate wallet addresses for correct format
   - Verify checksums for EVM addresses
   - Confirm Solana addresses are valid base58

3. **Signature Verification**
   - All transactions must be signed by user's wallet
   - Never store private keys
   - Use Privy's secure wallet management

### Data Security

1. **Profile Data**
   - Implement Row Level Security (RLS) in Supabase
   - Users can only access their own data
   - Validate profile_id in all queries

2. **API Security**
   - Authenticate all API requests
   - Rate limit AI queries
   - Validate input parameters

3. **Automation Security**
   - Limit automation rule complexity
   - Enforce transaction limits on automated actions
   - Require user confirmation for high-value rules
   - Log all automated executions

### Privacy Considerations

1. **Transaction Privacy**
   - Store minimal transaction metadata
   - Don't expose other users' transaction details
   - Aggregate analytics data securely

2. **Wallet Privacy**
   - Handled by Privy SDK - wallets are private to user by default
   - No additional implementation needed
   - Future: Implement privacy-enhanced receiving (post-MVP)

## Performance Optimization

### Database Optimization

1. **Indexing Strategy**
   - Index all foreign keys
   - Index frequently queried columns (created_at, status, chain)
   - Composite indexes for common query patterns

2. **Query Optimization**
   - Use pagination for transaction history
   - Limit analytics queries to recent data
   - Cache frequently accessed data (balances, APRs)

### Frontend Optimization

1. **Code Splitting**
   - Lazy load chain-specific components
   - Split bridge and lending modules
   - Defer AI chat until user interaction

2. **State Management**
   - Use React Query for server state caching
   - Minimize re-renders with proper memoization
   - Debounce balance updates

3. **Asset Optimization**
   - Optimize images and icons
   - Use Next.js Image component
   - Minimize bundle size

### Blockchain Optimization

1. **RPC Management**
   - Use reliable RPC providers (Alchemy, QuickNode)
   - Implement fallback RPC endpoints
   - Cache blockchain data when possible

2. **Transaction Batching**
   - Batch multiple reads into single RPC call
   - Use multicall for EVM chains
   - Optimize Solana transaction size

3. **Smart Wallet as Core Operation Layer** ⚠️ **CRITICAL**

**Strategy**: All operations execute through the primary smart wallet (Privy embedded wallet)

**Context**: 
- Every user has a primary smart wallet (EVM on Base) created during signup
- Users can link external wallets (EVM or Solana) for additional accounts
- **All app operations** (send, borrow, invest) execute via the primary smart wallet
- External wallets are only used for the Move component (transfer to primary wallet)

**Smart Wallet Benefits**:
- Transaction bundling (approve + transfer in one transaction)
- Gasless transactions (pay gas with USDC)
- Simplified UX for complex operations (lending, investing)
- No need for users to manage native tokens (ETH, SOL) for gas

**Implementation Strategy**:

```typescript
// Primary wallet is always used for operations
const primaryWallet = await getPrimaryWallet(profileId);

// For sending USDC
async function sendUSDC(params: SendParams) {
  // Always use primary wallet
  return executeFromPrimaryWallet({
    operation: 'transfer',
    ...params
  });
}

// For borrowing
async function borrowUSDC(params: BorrowParams) {
  // Always use primary wallet
  // Can bundle: approve collateral + deposit + borrow
  return executeBundledTransaction({
    operations: ['approve', 'deposit', 'borrow'],
    wallet: primaryWallet,
    ...params
  });
}

// For investing
async function depositToVault(params: InvestParams) {
  // Always use primary wallet
  // Can bundle: approve + deposit
  return executeBundledTransaction({
    operations: ['approve', 'deposit'],
    wallet: primaryWallet,
    ...params
  });
}
```

**External Wallet Handling** (Move Component Only):

```typescript
// External wallets can ONLY transfer USDC to primary wallet
async function moveFromExternalWallet(params: {
  externalAccountId: string;
  amount: string;
}) {
  const externalAccount = await getAccount(params.externalAccountId);
  const primaryAccount = await getPrimaryAccount(profileId);
  
  // Treat as traditional wallet (no bundling, requires gas)
  if (externalAccount.network === 'solana') {
    // Use Solana transfer (requires SOL for gas)
    return executeSolanaTransfer({
      from: externalAccount.address,
      to: primaryAccount.address,
      amount: params.amount
    });
  } else {
    // Use EVM transfer (requires ETH for gas)
    return executeEVMTransfer({
      from: externalAccount.address,
      to: primaryAccount.address,
      amount: params.amount
    });
  }
}
```

**Key Simplifications**:
- No need to check wallet type for most operations (always smart wallet)
- No need for complex wallet capability detection
- External wallets have single use case: move USDC to primary
- Users don't need to worry about gas tokens for regular operations
- Simplified transaction execution logic

**User Experience**:
- All operations happen from primary wallet (seamless)
- External wallets shown as "funding sources" that can move to primary
- No gas token management for primary wallet operations
- Clear messaging: "External wallets can only transfer to your main account"

## Deployment Strategy

### Environment Configuration

**Development**:
- Use testnets (Base Sepolia, Solana Devnet)
- Mock bridge transactions
- Simulated lending protocols

**Staging**:
- Use mainnets with $250 limit enforced
- Real bridge transactions (small amounts)
- Real lending protocols

**Production**:
- Full mainnet deployment
- $250 limit enforced
- Monitoring and alerting enabled

### Environment Variables

```bash
# Blockchain
NEXT_PUBLIC_BASE_RPC_URL=
NEXT_PUBLIC_SOLANA_RPC_URL=
NEXT_PUBLIC_CHAIN_ID=

# Authentication
NEXT_PUBLIC_PRIVY_APP_ID=
PRIVY_APP_SECRET=

# Database
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=

# AI
OPENAI_API_KEY=

# Protocols
MORPHO_CONTRACT_ADDRESS=
KAMINO_PROGRAM_ID=

# Bridge
WORMHOLE_API_KEY= # or ALLBRIDGE_API_KEY=

# Monitoring
SENTRY_DSN=
```

### Deployment Checklist

- [ ] Environment variables configured
- [ ] Database migrations applied
- [ ] RPC endpoints tested
- [ ] Privy app configured with correct domains
- [ ] Bridge SDK initialized
- [ ] Lending protocol contracts verified
- [ ] Transaction limits enforced
- [ ] Error logging enabled
- [ ] Analytics tracking configured
- [ ] SSL certificates valid
- [ ] Domain DNS configured (banb.finance)

## Monitoring and Observability

### Analytics Platform: Mixpanel

**Purpose**: Track user flow, funnel analysis, and identify bottlenecks

**Focus**: User journey and behavior patterns, not API performance

**Integration**: `lib/analytics/mixpanel.ts`

```typescript
import mixpanel from 'mixpanel-browser';

export function initMixpanel() {
  if (typeof window !== 'undefined') {
    mixpanel.init(process.env.NEXT_PUBLIC_MIXPANEL_TOKEN!);
  }
}

export function trackEvent(eventName: string, properties?: Record<string, any>) {
  if (typeof window !== 'undefined') {
    mixpanel.track(eventName, properties);
  }
}

export function identifyUser(profileId: string, traits?: Record<string, any>) {
  if (typeof window !== 'undefined') {
    mixpanel.identify(profileId);
    if (traits) mixpanel.people.set(traits);
  }
}

export function trackPageView(pageName: string, properties?: Record<string, any>) {
  trackEvent('Page Viewed', {
    page: pageName,
    ...properties
  });
}

export function trackButtonClick(buttonName: string, context?: Record<string, any>) {
  trackEvent('Button Clicked', {
    button: buttonName,
    ...context
  });
}
```

**Implementation in Components**:

```typescript
// In page components
useEffect(() => {
  trackPageView('Card Page');
}, []);

// In button handlers
<button onClick={() => {
  trackButtonClick('Move Funds', { source_account: accountId });
  handleMove();
}}>
  Move
</button>

// In transaction flows
async function executeTransaction() {
  trackEvent('Transaction Initiated', {
    type: 'send',
    chain: 'base',
    amount: amount
  });
  
  try {
    const result = await sendUSDC(params);
    trackEvent('Transaction Completed', {
      type: 'send',
      chain: 'base',
      success: true,
      duration: Date.now() - startTime
    });
  } catch (error) {
    trackEvent('Transaction Failed', {
      type: 'send',
      chain: 'base',
      error: error.message
    });
  }
}
```

**Key Events to Track**:

**User Journey**:
- `User Signed Up` - method (email/X/Farcaster)
- `Page Viewed` - page name, time spent
- `Button Clicked` - button name, context
- `Navigation` - from page, to page

**Transactions**:
- `Transaction Initiated` - type, chain, amount
- `Transaction Completed` - success/failure, duration
- `Transaction Failed` - error type, error message

**Features**:
- `Wallet Connected` - chain, is_primary
- `Account Added` - chain, account_type
- `Move Initiated` - source_chain, dest_chain, is_bridge
- `AI Query Submitted` - query_type
- `AI Rule Created` - rule_type
- `AI Rule Executed` - rule_id, success
- `Lending Action` - action (borrow/repay), protocol, amount
- `Card Simulation` - merchant, amount

**Errors & Bottlenecks**:
- `Error Occurred` - error_type, context, page
- `Insufficient Balance` - required, available, shortfall
- `Transaction Rejected` - reason

**Funnel Analysis**:
- Track complete user flows:
  - Signup → Add Account → First Transaction
  - View Card → Borrow → Simulate Spending
  - AI Chat → Create Rule → Rule Executed
  - Move Initiated → Bridge → Completed

**Time Tracking**:
- Page view duration (time between page views)
- Transaction completion time
- AI response time
- Bridge completion time

**No API Route Tracking**: Focus on client-side user behavior only

### Key Metrics

1. **Transaction Metrics**
   - Transaction success rate by chain
   - Average transaction time
   - Failed transaction reasons
   - Bridge completion rate

2. **User Metrics**
   - Daily active users
   - Wallet connections by chain
   - Average portfolio value
   - Feature usage (lending, bridge, AI)
   - User retention and engagement

3. **System Metrics**
   - API response times
   - Database query performance
   - RPC endpoint latency
   - Error rates

### Logging Strategy

**Structured Logging**:
```typescript
logger.info('Transaction initiated', {
  profileId: user.id,
  chain: 'solana',
  amount: '100',
  type: 'send'
});
```

**Log Levels**:
- ERROR: Failed transactions, system errors
- WARN: Approaching limits, slow queries
- INFO: Successful transactions, user actions
- DEBUG: Detailed execution flow

### Alerting

**Critical Alerts**:
- Transaction failure rate > 5%
- Bridge stuck for > 10 minutes
- Database connection errors
- RPC endpoint failures

**Warning Alerts**:
- High transaction volume
- Slow query performance
- Low RPC rate limits

## Future Enhancements (Post-MVP)

1. **Additional Chains**
   - Ethereum mainnet
   - Polygon
   - Arbitrum
   - Optimism

2. **Enhanced Privacy**
   - Fluidkey-style stealth addresses
   - Private transaction routing
   - Zero-knowledge proofs

3. **Advanced Lending**
   - Multiple collateral types
   - Leveraged positions
   - Yield optimization

4. **Fiat Integration**
   - On/off ramp providers
   - Bank account linking
   - ACH transfers

5. **Social Features**
   - Farcaster miniapp integration
   - Social payments
   - Shared accounts

6. **Advanced Automation**
   - Complex rule conditions
   - Multi-step workflows
   - Scheduled transactions

7. **Portfolio Management**
   - Asset allocation recommendations
   - Rebalancing automation
   - Tax reporting

## Conclusion

This design provides a comprehensive architecture for Banb MVP v1, extending the existing foundation with multi-chain support, cross-chain bridging, lending on both Base and Solana, AI-powered analytics and automation, and simulated card spending. The modular design allows for future chain additions and feature enhancements while maintaining the core profile-centric architecture and $250 transaction limit for safe MVP operation.

